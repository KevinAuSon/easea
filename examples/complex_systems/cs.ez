/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.

  use : easea -gp regression.ez
	make

	OR (if you'd like to exploit a CUDA-compatible graphic card)

	easea -cuda_gp regression.ez
        make

  in order to generate and compile this code.
__________________________________________________________*/

\User declarations :
#define VAR_LEN 1

#include <math.h>
#include "CSEnvironment.h"

#define NB_AGENTS 40
#define NB_STEPS 10
#define LIM 50
#define MOVE 2

class Boid : public CSAgent{
public:
    //attribute[0] : position
    //attribute[1] : direction
    //the second argument is the axis
    int attributes[2][2];

    Boid() {
        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j)
                attributes[i][j] = random(2, 5);
        }
    }

    Boid(const Boid& other) {
        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j)
                attributes[i][j] = other.attributes[i][j];
        }
    }

    ~Boid(){}

    bool sense(CSAgent* other) {
        int DISTANCE = 10;
        int *posB = ((Boid*)other)->attributes[0];
        int *posA = this->attributes[0];

        return sqrt(pow(posB[0] - posA[0], 2) + pow(posB[1] - posA[1], 2)) <= DISTANCE;
    }

    void action() {
        for (int i = 0; i < 2; ++i) {
            attributes[0][i] += attributes[1][i] ;
            attributes[0][i] = attributes[0][i] % LIM;
        }
    }

    bool samePos(Boid* other) {
        return attributes[0][0] == other->attributes[0][0] &&
               attributes[0][1] == other->attributes[0][1];
    }

    std::string toString() {
        std::ostringstream oss;
        oss << "position[" << attributes[0][0] << "," << attributes[0][1] << "] "
            << "axis[" << attributes[1][0] << "," << attributes[1][1] << "]";

        return oss.str();
    }
};

int nextId = 0;
CSEnvironment<Boid>* ENV_DEFAULT;
CSEnvironment<Boid>** envs;

\end

\User functions:

template <typename T>
float EVAL(List<T>* agentList) {
    float result = NB_AGENTS;
    for(List<T>* aList = agentList; aList->hasNext(); aList = aList->getNext()) {
        T* agent = aList->getElt();
        bool isDead = false;

        for(List<T>* curs = agentList; curs->hasNext(); curs = curs->getNext()) {
            if(agent != curs->getElt() && agent->samePos((Boid*)curs->getElt()))
                isDead = true;
        }

        if(isDead) result--;
    }

    return result;
}
\end



\Before everything else function:
{
    //ENV_DEFAULT = new CSEnvironment<Boid>(NB_AGENTS);
    envs = new CSEnvironment<Boid>*[EZ_POP_SIZE];
    //std::cout << ENV_DEFAULT->toString() << std::endl;
}
\end

\After everything else function:
{
  std::cout << toString(((IndividualImpl*)EA->population->Best)->root) << std::endl;
}
\end

\At the beginning of each generation function:
{
  //cout << "At the beginning of each generation function called" << endl;
}
\end

\At the end of each generation function:
{
  //cout << "At the end of each generation function called" << endl;
}
\end

\At each generation before reduce function:
 //cout << "At each generation before replacement function called" << endl;
\end


\User classes :
GenomeClass {
  GPNode* root;
  int id;
}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser :
{
  Genome.root = ramped_hh();
    Genome.id = nextId++;
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  simple_mutator(&Genome);
  return 1;
}
\end


\begin operator description :
OP_ERC, "ERC", 0, {RESULT=ERC;};
OP_DISTANCE, "get_distance", 1, {
{
    int *posA = self->attributes[((int)OP1)%2];
    int *posB = other->attributes[((int)OP1)%2];

    //get the euclidian distance between the agent and the other
    RESULT = sqrt(pow(posB[0] - posA[0], 2) + pow(posB[1] - posA[1], 2));
}
};
OP_CHANGE_DIRECTION, "change_direction", 2, {
{
  int change = ((int)OP2);
  self->attributes[1][((int)OP1)%3] += change % MOVE;
  RESULT = change;
}
};
OP_ADD, "+", 2, {RESULT=OP1+OP2;};
OP_SUB, "-", 2, {RESULT=OP1-OP2;};
OP_MUL, "*", 2, {RESULT=OP1*OP2;};
OP_DIV, "/", 2, {
  if( !OP2 ) RESULT = 1;
  else RESULT = OP1/OP2;
};

\end


\GenomeClass::evaluator header:
    envs[this->id] = new CSEnvironment<Boid>(NB_AGENTS);
    envs[this->id]->compute(NB_STEPS, recEval, this->root);
    float res = envs[this->id]->evaluate(EVAL);
    //std::cout << envs[this->id]->toString() << std::endl;
    //delete envs[this->id];
\end

\GenomeClass::evaluator for each fc :
\end

\GenomeClass::evaluator accumulator :
    return res;
\end


\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 30   	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 100			//POP_SIZE
  Offspring size : 100 // 40%
  Mutation probability : 0.1       // MUT_PROB
  Crossover probability : 0.9      // XOVER_PROB
  Evaluator goal : maximise      // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:false				//Default: 0

  //  Remote island model: true
  //IP	  file: ip.txt 			//File containing all the remote island's IP
  //Server port : 2929
  //Migration probability: 0.33

  Save population: false
  Start from file:false

  max init tree depth : 4
  min init tree depth : 2

  max tree depth : 8

  size of prog buffer : 200000000
\end
